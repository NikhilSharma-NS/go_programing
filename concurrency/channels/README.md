### Channels

1) Communication data between Goroutines
2) synchronise Goroutines
3) Typed
4) Thread-Safe


##### Declare and Initilize

var ch chan T
ch = make(chan T)

##### <- operator

pointer operator is used for sending and receiving the value from channel

the arrow indicates the direction of data flow

Send  
```
ch <- v
```
receive

```
v = <-ch
```

ch <- value
Channel wait fro a receiver to be raedy then Channels are blocking

<-ch
Go Rountines wait for a value to se sent then Channels are blocking

##### close(ch1)

No more value to be sent


value,ok = <- ch
ok = true , value generated by a write
ok = false , value generated by a close


1) Simple channel Sum program

```
package main

import (
	"fmt"
	"time"
)

func main() {
	channel := make(chan int)
	go func(a, b int) {
		c := a + b
		channel <- c
		fmt.Println("SUm", c)
	}(1, 2)
	fmt.Printf("Main function is having SUM %v", <-channel)
	time.Sleep(1 * time.Millisecond)
}

```

2) 

```
for value := range ch{

}
```
iterate over values received from a channel
Loop automatically breaks, when a channel is closed
range does not return the second boolean value

3) UnBuffered Channel

Synchrouns

```
G1      -> G2
sender     receiver
```
ch:= make(chan Type)

4) Buffered Channel

channel are given capacity 
in-memory FIFO queue
Asynchronous

ch:= make(chan Type,capacity)

```
G1 -> | | | -> G2
Sender        receiver
```

#### Example 

```
package main

import "fmt"

func main() {
	channel := make(chan int)

	go func() {

		for counter := 0; counter < 6; counter++ {
			channel <- counter
		}
		close(channel)
	}()

	for value := range channel {
		fmt.Printf("Value in main thread: %v \n", value)

	}

}

```

Buffer Channel Example 


```
package main

import "fmt"

func main() {
	channel := make(chan int, 6)

	go func() {
		defer close(channel)
		for counter := 1; counter <= 6; counter++ {
			fmt.Println("Sending ", counter)
			channel <- counter
		}
	}()

	for v := range channel {
		fmt.Printf("Received %v\n", v)

	}

}

```


#### Channel Direction

- when using channels as function parameters, you can specify if a channel is meant to only send or receive values
- this spicificity increase the type-safety of the program

func pong(in <-chan string,out chan<- string){}

