### Channels

1) Communication data between Goroutines
2) synchronise Goroutines
3) Typed
4) Thread-Safe


##### Declare and Initilize

var ch chan T
ch = make(chan T)

##### <- operator

pointer operator is used for sending and receiving the value from channel

the arrow indicates the direction of data flow

Send  
```
ch <- v
```
receive

```
v = <-ch
```

ch <- value
Channel wait fro a receiver to be raedy then Channels are blocking

<-ch
Go Rountines wait for a value to se sent then Channels are blocking

##### close(ch1)

No more value to be sent


value,ok = <- ch
ok = true , value generated by a write
ok = false , value generated by a close


1) Simple channel Sum program

```
package main

import (
	"fmt"
	"time"
)

func main() {
	channel := make(chan int)
	go func(a, b int) {
		c := a + b
		channel <- c
		fmt.Println("SUm", c)
	}(1, 2)
	fmt.Printf("Main function is having SUM %v", <-channel)
	time.Sleep(1 * time.Millisecond)
}

```

2) 

```
for value := range ch{

}
```
iterate over values received from a channel
Loop automatically breaks, when a channel is closed
range does not return the second boolean value

3) UnBuffered Channel

Synchrouns

```
G1      -> G2
sender     receiver
```
ch:= make(chan Type)

4) Buffered Channel

channel are given capacity 
in-memory FIFO queue
Asynchronous

ch:= make(chan Type,capacity)

```
G1 -> | | | -> G2
Sender        receiver
```

#### Example 

```
package main

import "fmt"

func main() {
	channel := make(chan int)

	go func() {

		for counter := 0; counter < 6; counter++ {
			channel <- counter
		}
		close(channel)
	}()

	for value := range channel {
		fmt.Printf("Value in main thread: %v \n", value)

	}

}

```

Buffer Channel Example 


```
package main

import "fmt"

func main() {
	channel := make(chan int, 6)

	go func() {
		defer close(channel)
		for counter := 1; counter <= 6; counter++ {
			fmt.Println("Sending ", counter)
			channel <- counter
		}
	}()

	for v := range channel {
		fmt.Printf("Received %v\n", v)

	}

}

```


#### Channel Direction

- when using channels as function parameters, you can specify if a channel is meant to only send or receive values
- this spicificity increase the type-safety of the program

func pong(in <-chan string,out chan<- string){}


#### Default value - Channels

- default value for channels : nil

var ch chan interface{}

- reading/writing to a nil channel will block forever

var ch chan interface{}

<-ch

ch <- struc{}{}

- closing nil channel will panic 

var ch chan interface{}
close(ch)

- Ensure the channels are initilized first

- Owner os channel is a goroutine that instantiates,writes and closes a channel

- Channel utilizers only have a read-only view into the channel

#### Ownership of channels avoids

- Deadlocking by writing to nil channel
- closing a nil channel
- writing to a closed channel
- closing a channel more than once

```
package main

import "fmt"

func main() {
	// create channel owner ,which creates channel
	// return receive only channle to caller
	// spins a goroutine ,which
	// writes data into channel and
	// closes the channel when done

	owner := func() <-chan int {
		ch := make(chan int)
		go func() {
			defer close(ch)
			for counter := 0; counter < 5; counter++ {
				ch <- counter
			}
		}()
		return ch

	}
	consumer := func(ch <-chan int) {

		// read value of channel
		for value := range ch {
			fmt.Println("Received ", value)
		}
		fmt.Println("Done receiving ")
	}

	ch := owner()
	consumer(ch)

}

```

##### Deep dive in channel

1) https://golang.org/src/runtime/chan.go

ch:= make (chan int,3)

- hchan struct is allocated in heap 
- make() returns a pointer to it
- Since 'ch' is pointer it can be between functions for send and receive

```
---------------
Stack |
---------------

--------------
Heap |
--------------

2) Send and Receive work 

```
ch:= make(chan int,3)

// G1

func G1(ch chan<- int){
for _,v:= range[]int{1,2,3,4}
ch<-v
}

// G2

func G2(ch <-chan int){
	for V:= range ch{
		fmt.Println(v)
	}
}
```
Stage1 

```
hchan
----------------------
buf     circular queue    -> | | | Empty 
----------------------
lock    mutex
----------------------
sendx   send index
----------------------
recvx   recv index
----------------------

```

Step 2 G1 is ch <-v

```
hchan
----------------------        2 1 0
buf     circular queue    -> | | |1| 2) enqueue 
----------------------
lock    mutex            1) Acquire Lock 3) release lock 
----------------------
sendx   send index
----------------------
recvx   recv index
----------------------

```

Step 3 G2 V:= <-ch

```
hchan
----------------------        2 1 0
buf     circular queue    -> | | |1| 2) dequeue  3) copy to v
----------------------
lock    mutex            1) Acquire Lock 5) release lock 
----------------------
sendx   send index
----------------------
recvx   recv index       4) inc recvx by 1 
----------------------

```

- There is no memory share between goroutines
- Goroutines copy elements into and from hchan
- hchan is protected by mutex lock

3) Buffers Full

```
hchan
----------------------        2  1  0
buf     circular queue    -> |3 |2 | 1 |   1) enqueue 1,2,3 and 2) full 
----------------------
lock    mutex            
----------------------
sendx   send index         3) ch <- 4

                                      ----------------------
									           G -> G1
									  -----------------------
									          elem -> 4
									  -----------------------
									                          Sudog
									  -----------------------
----------------------
recvx   recv index
----------------------


G1 calls gopark()

when channel buffer is full and a goroutines tries to sed value
a) Sender Goroutines gets blocked , it is parked in sendQ
b) data will be saved in the elem field of the sugod structure
c) when Receiver comes along, it dequeues the value from buffer
d) enqueues the data from elem field to the buffer
e) Pops the goroutines in sendq and puts it into runanble state

4) Buffer is empty 

G2 tries to recv on empty channel

v:=<-ch

```
hchan
----------------------        2 1 0
buf     circular queue    -> | | | | empty channel 
----------------------
lock    mutex             
----------------------
sendx   send index
----------------------     -----------------
recvx   recv index    ->          G        -> G2
                           -----------------
						         elem       -> v
                           -----------------

                           -----------------
----------------------

```


when gorountine calls receive on empty buffer

a) Goroutine is blocked it is parked into recvq
b) elem field of the sudog structure holds the reference to the stack
variable of receiver goroutine
c) when sender comes along Sender finds the goroutine in recvq
d) sender copies the data into the stack variable on the receiver goroutine directly 
e) Pops the goruntine in recvq and puts into runnable state

5) Send and Receive on unbuffered channel

5.1) Send on unbuffered channel

a) when sender goroutine wants to send values
b) if there is corresponding receiver waiting in recvq
c) Sender will write the value directly into receiver goroutine stack variable
d) Sender goroutine puts the receiver goroutine back to runnable state
e) if there is no receiver goroutine in recvq
f) Sender gets parked into sendq
g) data is saved in elem field in sudog struct
h) Receiver Comes and copies teh data
i) puts the sender to runnable state again

5.2) Receive on unbuffered channel
a) Receiver goroutine wants to receive value 
b) If it find a goroutine in waiting in sendq
c) Receiver copies the value in elem field to its variable
d) Puts the sender goroutine to runnable state
e) if there was no sender goroutine in sendq
f) Receiver gets parked into recvq
g) Reference to variable is saved in elem field in sudog struct
h) Sender comes and copies the data directly to receiver stack variable
i) Puts the receiver to runnable state


1) hchan struct represents channel
2) it contains circular ring buffer and mutex lock
3) Goroutines that get blocked on send or recv are parked in sendq or recvq
4) Go scheduler moves the blocked goroutines out os OS thread
5) once channel opeartion is complete go routine is moved back to local run queue
